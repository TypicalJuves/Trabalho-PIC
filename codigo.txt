#include <Servo.h>
#include <HCSR04.h>

#define p1m1 4//pino 1 motor 1
#define p2m1 5//pino 2 motor 1
#define pve1m1 3//pino para velocidade velocidade do motor 1
#define p1m2 7//pino 1 motor 2
#define p2m2 8//pino 2 motor 2
#define pve1m2 6//pino para velocidade velocidade do motor 2
#define pservo 10 
#define p_trigger 11 
#define p_echo 12 
#define tmp_giro 500

unsigned long tmpd[100] = millis();
unsigned long millix = millis();
char dir[100];
int vet=0;

Servo servo; 
UltraSonicDistanceSensor distanceSensor(p_trigger, p_echo);

int vel, situacao;//vel - indica velocidade de rotação do motor;  
float dist_cm, distMinima=30;

class Motor{//define uma classe chamada Motor para encapsular as funcionalidades de controle de um motor
public:
  //declara 3 variáveis inteiras privadas dentro da classe Motor: p1(pino 1 do motor), p2(pino 2 do motor) e pv(pino de velocidade)
  int p1, p2, pv;
  
  //define o construtor da classe Motor, que recebe como argumentos os pinos do motor e o pino de velocidade
  Motor(int p1, int p2, int v){
    this->p1=p1;//atribui o valor do argumento p1 ao atributo p1 do objeto
    this->p2=p2; 
    this->pv=v;
    pinMode(p1,OUTPUT);//a informação sai do arduino e vai para a placa controladora
    pinMode(p2,OUTPUT);
    pinMode(pv,OUTPUT);
    digitalWrite(p1,LOW);
    digitalWrite(p2,LOW);
    analogWrite(pv,0);
  }

  void frente(int v){
    digitalWrite(p1,HIGH);
    digitalWrite(p2,LOW);
    analogWrite(pv,v);
  }
  
  void tras(int v){
    digitalWrite(p1,LOW);
    digitalWrite(p2,HIGH);
    analogWrite(pv,v);
  }

  void para(){
    digitalWrite(p1,LOW);
    digitalWrite(p2,LOW);
    analogWrite(pv,0);
  }

  void freia(){
    digitalWrite(p1,HIGH);
    digitalWrite(p2,HIGH);
    analogWrite(pv,255);
  }
};

Motor *me=new Motor(p1m1,p2m1,pve1m1);//md controle dos 2 motores da esquerda
Motor *md=new Motor(p1m2,p2m2,pve1m2);//me controle dos 2 motores da direita

void esquerda(int v){
  md->frente(v);
  me->tras(v);
}

void direita(int v){
  md->tras(v);
  me->frente(v);
}

void frente(int v){
  md->frente(v);
  me->frente(v);
}

void tras(int v){
  md->tras(v);
  me->tras(v);
}

void para(){
  md->para();
  me->para();
}

void escolherLado(){
  float d1, d2;//d1=direita, d2=esquerda
  d1=d2=0;
  delay(500);
  servo.write(0);//0 - aponta o sensor para a direita
  delay(500);
  d1=distanceSensor.measureDistanceCm();
  delay(250);
  servo.write(180);//180 - aponta o sensor para a esquerda
  delay(750);
  d2=distanceSensor.measureDistanceCm();
  delay(250);
  servo.write(90);//90 - aponta o sensor para a frente
  delay(250);
  Serial.print("Direita.: ");Serial.println(d1);
  Serial.print("Esquerda.: ");Serial.println(d2);
  if(d1>d2){
    Serial.println("Virando para direita");
    direita(vel);
    delay(tmp_giro);
    dir[vet] = 'E';//Grava a direção do movimento
  }else{
    Serial.println("Virando para esquerda");
    esquerda(vel);
    delay(tmp_giro);
    dir[vet] = 'D';//Grava a direção do movimento
  }
  vet++;
  millix = millis();
}

void Gira180(){
  direita(vel);
  delay(tmp_giro):
  direita(vel);
  delay(tmp_giro):
}

void contra(){
  Gira180();
  while(1){
    while((millis() - millix) < tmpd[vet]){
      frente(vel);
    }
    vet--;
    if(vet == -1){
      break;
    }
    if(dir[vet] == 'D'){
      direita(vel);
      delay(tmp_giro);
    }
    else if(dir[vet] == 'E'){
      esquerda(vel);
      delay(tmp_giro);
    }
  }
  para();
}

void setup() {
  vel=200;
  servo.attach(pservo);
  servo.write(90);//90 mantém de início o sensor ultrassônico apontado para frente
  Serial.begin(9600);
}


void loop() {
  if(millis() < 60000){
    dist_cm=distanceSensor.measureDistanceCm();
    if(dist_cm < distMinima && dist_cm != -1){
      tmpd[vet] = (millis() - millix);//Grava o tempo de duração do movimento
      freia();
      escolherLado();
    }else{
      frente(vel);
    }
  }
  else{
    tmpd[vet] = (millis() - millix);
    millix = millis();
    contra();
  }
}
